<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>pixi-svg</title>
    
    <meta name="description" content="SVG to Graphics DisplayObject for PIXI" />
    
        <meta name="keywords" content="PixiJS, Rendering, Graphics, SVG, Vector" />
        <meta name="keyword" content="PixiJS, Rendering, Graphics, SVG, Vector" />
    
    
    
    
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <script src="scripts/jquery.min.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link href="https://fonts.googleapis.com/css?family=Libre+Franklin:400,700" rel="stylesheet">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/bootstrap.min.css">
    <link type="text/css" rel="stylesheet" href="styles/main.css">

    
    <script>
    var config = {"monospaceLinks":false,"cleverLinks":false,"applicationName":"pixi-svg","meta":{"title":"pixi-svg","description":"SVG to Graphics DisplayObject for PIXI","keyword":"PixiJS, Rendering, Graphics, SVG, Vector"},"linenums":true,"default":{"outputSourceFiles":true}};
    </script>
    

    
</head>
<body>
<div id="wrap" class="clearfix">
    
<div class="navigation">
    <h3 class="applicationName"><a href="index.html">pixi-svg</a></h3>
    <button id="menuToggle" class="btn btn-link btn-lg menu-toggle">
        <span class="glyphicon glyphicon-menu-hamburger"></span>
    </button>
    <div class="search">
        <input id="search" type="text" class="form-control input-md" placeholder="Search...">
    </div>
    <ul class="list">
    
    
        <li class="item" data-name="PIXI.SVG">
            <span class="title  ">
                
                
                    <a href="PIXI.SVG.html">PIXI.SVG</a>
                
            </span>
            
            <ul class="members itemMembers">
            
            </ul>
            
            <ul class="typedefs itemMembers">
            
            </ul>
            
            <ul class="typedefs itemMembers">
            
            </ul>
            
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li class="parent  " data-name="PIXI.SVG#drawSVG"><a href="PIXI.SVG.html#drawSVG">drawSVG</a></li>
            
            </ul>
            
            <ul class="events itemMembers">
            
            </ul>
            
        </li>
    
    </ul>
</div>

    <div class="main">
        <h1 class="page-title" data-filename="-_Users_mattkarl_GitHub_bigtimebuddy_pixi-svg_src_SVG.js.html">Source: /Users/mattkarl/GitHub/bigtimebuddy/pixi-svg/src/SVG.js</h1>
        


    
    <section>
        <header>
            <div class="header content-size">
                <h2>/Users/mattkarl/GitHub/bigtimebuddy/pixi-svg/src/SVG.js</h2>
            </div>
        </header>
        <article>
            <pre id="source-code" class="prettyprint source linenums"><code>import { Graphics } from '@pixi/graphics';
import dPathParser from 'd-path-parser';
import color from 'tinycolor2';

/**
 * Scalable Graphics drawn from SVG image document.
 * @class SVG
 * @extends PIXI.Graphics
 * @memberof PIXI
 * @param {SVGSVGElement|SVGElement|string} [svg] - Inline SVGElement `&lt;svg>` or buffer.
 */
class SVG extends Graphics
{
    constructor(svg)
    {
        super();

        if (svg)
        {
            this.drawSVG(svg);
        }
    }

    /**
     * Draw an SVG element.
     * @method PIXI.SVG#drawSVG
     * @param {SVGSVGElement|SVGElement|string} svg - Inline SVGElement `&lt;svg>` or buffer.
     * @return {PIXI.SVG} Element suitable for chaining.
     */
    drawSVG(svg)
    {
        if (typeof svg === 'string')
        {
            const div = document.createElement('div');

            div.innerHTML = svg.trim();
            svg = div.querySelector('svg');
        }

        if (!svg)
        {
            throw new Error('Missing &lt;svg> element in SVG constructor');
        }

        this._svgFill(svg);
        this._svgChildren(svg.children);

        return this;
    }

    /**
     * Create a PIXI Graphic from SVG element
     * @private
     * @method
     * @param {Array&lt;*>} children - Collection of SVG nodes
     * @param {Boolean} [inherit=false] Whether to inherit fill settings.
     */
    _svgChildren(children, inherit = false)
    {
        for (let i = 0; i &lt; children.length; i++)
        {
            const child = children[i];

            this._svgFill(child, inherit);
            switch (child.nodeName.toLowerCase())
            {
                case 'path': {
                    this._svgPath(child);
                    break;
                }
                case 'circle':
                case 'ellipse': {
                    this._svgCircle(child);
                    break;
                }
                case 'rect': {
                    this._svgRect(child);
                    break;
                }
                case 'polygon': {
                    this._svgPoly(child, true);
                    break;
                }
                case 'polyline': {
                    this._svgPoly(child);
                    break;
                }
                case 'g': {
                    break;
                }
                default: {
                    // eslint-disable-next-line no-console
                    console.info(`[PIXI.SVG] &lt;${child.nodeName}> elements unsupported`);
                    break;
                }
            }
            this._svgChildren(child.children, true);
        }
    }

    /**
     * Convert the Hexidecimal string (e.g., "#fff") to uint
     * @private
     * @method
     */
    _hexToUint(hex)
    {
        if (hex[0] === '#')
        {
            // Remove the hash
            hex = hex.substr(1);

            // Convert shortcolors fc9 to ffcc99
            if (hex.length === 3)
            {
                hex = hex.replace(/([a-f0-9])/ig, '$1$1');
            }

            return parseInt(hex, 16);
        }

        const { r, g, b } = color(hex).toRgb();

        return (r &lt;&lt; 16) + (g &lt;&lt; 8) + b;
    }

    /**
     * Render a &lt;ellipse> element or &lt;circle> element
     * @private
     * @method
     * @param {SVGCircleElement} node
     */
    _svgCircle(node)
    {
        let heightProp = 'r';
        let widthProp = 'r';
        const isEllipse = node.nodeName === 'elipse';

        if (isEllipse)
        {
            heightProp += 'x';
            widthProp += 'y';
        }
        const width = parseFloat(node.getAttribute(widthProp));
        const height = parseFloat(node.getAttribute(heightProp));
        const cx = node.getAttribute('cx');
        const cy = node.getAttribute('cy');
        let x = 0;
        let y = 0;

        if (cx !== null)
        {
            x = parseFloat(cx);
        }
        if (cy !== null)
        {
            y = parseFloat(cy);
        }
        if (!isEllipse)
        {
            this.drawCircle(x, y, width);
        }
        else
        {
            this.drawEllipse(x, y, width, height);
        }
    }

    /**
     * Render a &lt;rect> element
     * @private
     * @method
     * @param {SVGRectElement} node
     */
    _svgRect(node)
    {
        const x = parseFloat(node.getAttribute('x'));
        const y = parseFloat(node.getAttribute('y'));
        const width = parseFloat(node.getAttribute('width'));
        const height = parseFloat(node.getAttribute('height'));
        const rx = parseFloat(node.getAttribute('rx'));

        if (rx)
        {
            this.drawRoundedRect(x, y, width, height, rx);
        }
        else
        {
            this.drawRect(x, y, width, height);
        }
    }

    /**
     * Convert the SVG style name into usable name.
     * @private
     * @param {string} name
     * @return {string} name used to reference style
     */
    _convertStyleName(name)
    {
        return name
            .trim()
            .replace('-width', 'Width')
            .replace(/.*-(line)?/, '');
    }

    /**
     * Get the style property and parse options.
     * @private
     * @method
     * @param {SVGElement} node
     * @return {Object} Style attributes
     */
    _svgStyle(node)
    {
        const style = node.getAttribute('style');
        const result = {
            fill: node.getAttribute('fill'),
            opacity: node.getAttribute('opacity'),
            stroke: node.getAttribute('stroke'),
            strokeWidth: node.getAttribute('stroke-width'),
            cap: node.getAttribute('stroke-linecap'),
            join: node.getAttribute('stroke-linejoin'),
            miterLimit: node.getAttribute('stroke-miterlimit'),
        };

        if (style !== null)
        {
            style.split(';').forEach((prop) =>
            {
                const [name, value] = prop.split(':');

                if (name)
                {
                    const convertedName = this._convertStyleName(name);

                    if (!result[convertedName])
                    {
                        result[convertedName] = value.trim();
                    }
                }
            });
        }

        return result;
    }

    /**
     * Render a polyline element.
     * @private
     * @method
     * @param {SVGPolylineElement} node
     */
    _svgPoly(node, close)
    {
        const points = node.getAttribute('points')
            .split(/[ ,]/g)
            .map((p) => parseInt(p, 10));

        this.drawPolygon(points);

        if (close)
        {
            this.closePath();
        }
    }

    /**
     * Set the fill and stroke style.
     * @private
     * @method
     * @param {SVGElement} node
     * @param {Boolean} inherit
     */
    _svgFill(node, inherit)
    {
        const { fill, opacity, stroke, strokeWidth, cap, join, miterLimit } = this._svgStyle(node);
        const defaultLineWidth = stroke !== null ? 1 : 0;
        const lineWidth = strokeWidth !== null ? parseFloat(strokeWidth) : defaultLineWidth;
        const lineColor = stroke !== null ? this._hexToUint(stroke) : this.lineColor;

        if (fill)
        {
            if (fill === 'none')
            {
                this.beginFill(0, 0);
            }
            else
            {
                this.beginFill(
                    this._hexToUint(fill),
                    opacity !== null ? parseFloat(opacity) : 1,
                );
            }
        }
        else if (!inherit)
        {
            this.beginFill(0);
        }

        this.lineStyle({
            width: stroke === null &amp;&amp; strokeWidth === null &amp;&amp; inherit ? this.line.width : lineWidth,
            color: stroke === null &amp;&amp; inherit ? this.line.color : lineColor,
            cap: cap === null &amp;&amp; inherit ? this.line.cap : cap,
            join: join === null &amp;&amp; inherit ? this.line.join : join,
            miterLimit: miterLimit === null &amp;&amp; inherit ? this.line.miterLimit : parseFloat(miterLimit),
        });

        if (node.getAttribute('fill-rule'))
        {
            // eslint-disable-next-line no-console
            console.info('[PIXI.SVG] "fill-rule" attribute is not supported');
        }
    }

    /**
     * Render a &lt;path> d element
     * @method
     * @param {SVGPathElement} node
     */
    _svgPath(node)
    {
        const d = node.getAttribute('d');
        let x;
        let y;
        const commands = dPathParser(d.trim());

        for (let i = 0; i &lt; commands.length; i++)
        {
            const command = commands[i];

            switch (command.code)
            {
                case 'm': {
                    this.moveTo(
                        x += command.end.x,
                        y += command.end.y,
                    );
                    break;
                }
                case 'M': {
                    this.moveTo(
                        x = command.end.x,
                        y = command.end.y,
                    );
                    break;
                }
                case 'H': {
                    this.lineTo(x = command.value, y);
                    break;
                }
                case 'h': {
                    this.lineTo(x += command.value, y);
                    break;
                }
                case 'V': {
                    this.lineTo(x, y = command.value);
                    break;
                }
                case 'v': {
                    this.lineTo(x, y += command.value);
                    break;
                }
                case 'Z': {
                    this.closePath();
                    break;
                }
                case 'L': {
                    this.lineTo(
                        x = command.end.x,
                        y = command.end.y,
                    );
                    break;
                }
                case 'l': {
                    this.lineTo(
                        x += command.end.x,
                        y += command.end.y,
                    );
                    break;
                }
                case 'C': {
                    this.bezierCurveTo(
                        command.cp1.x,
                        command.cp1.y,
                        command.cp2.x,
                        command.cp2.y,
                        x = command.end.x,
                        y = command.end.y,
                    );
                    break;
                }
                case 'c': {
                    const currX = x;
                    const currY = y;

                    this.bezierCurveTo(
                        currX + command.cp1.x,
                        currY + command.cp1.y,
                        currX + command.cp2.x,
                        currY + command.cp2.y,
                        x += command.end.x,
                        y += command.end.y,
                    );
                    break;
                }
                case 's':
                case 'q': {
                    const currX = x;
                    const currY = y;

                    this.quadraticCurveTo(
                        currX + command.cp.x,
                        currY + command.cp.y,
                        x += command.end.x,
                        y += command.end.y,
                    );
                    break;
                }
                case 'S':
                case 'Q': {
                    this.quadraticCurveTo(
                        command.cp.x,
                        command.cp.y,
                        x = command.end.x,
                        y = command.end.y,
                    );
                    break;
                }
                case 'a': {
                    const RAD = (Math.PI / 180);

                    this.arc(
                        (x += command.end.x),
                        (y += command.end.y),
                        command.rotation * RAD,
                        command.radii.x * RAD,
                        command.radii.y * RAD,
                        command.clockwise,
                    );
                    break;
                }
                case 'A': {
                    const RAD = (Math.PI / 180);

                    this.arc(
                        (x = command.end.x),
                        (y = command.end.y),
                        command.rotation * RAD,
                        command.radii.x * RAD,
                        command.radii.y * RAD,
                        command.clockwise
                    );
                    break;
                }
                default: {
                    // eslint-disable-next-line no-console
                    console.info('[PIXI.SVG] Draw command not supported:', command.code, command);
                    break;
                }
            }
        }
    }
}

export { SVG };
</code></pre>
        </article>
    </section>






        

        <footer class="content-size">
            <div class="footer">
                Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.4</a> on Thu Apr 08 2021 13:38:37 GMT-0700 (Pacific Daylight Time)
            </div>
        </footer>
    </div>
</div>
<script>prettyPrint();</script>
<script src="scripts/main.js"></script>


</body>
</html>
